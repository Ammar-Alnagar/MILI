"""
Core type definitions and utilities for MILI GPU kernels.
Provides fundamental types for GPU computation and memory management.
"""

from sys.info import simdwidthof


# ============================================================================
# Data Type Enumerations
# ============================================================================

@register_passable("trivial")
struct DType:
    """GPU data type enumeration."""
    var value: UInt8
    
    alias float32 = DType(0)
    alias float16 = DType(1)
    alias bfloat16 = DType(2)
    alias int8 = DType(3)
    alias uint8 = DType(4)
    alias int32 = DType(5)
    alias uint32 = DType(6)
    alias int64 = DType(7)
    alias uint64 = DType(8)
    
    fn __eq__(self, other: DType) -> Bool:
        return self.value == other.value
    
    fn __ne__(self, other: DType) -> Bool:
        return self.value != other.value
    
    fn size_bytes(self) -> Int:
        """Get size in bytes for this data type."""
        if self.value == 0:  # float32
            return 4
        elif self.value == 1:  # float16
            return 2
        elif self.value == 2:  # bfloat16
            return 2
        elif self.value == 3:  # int8
            return 1
        elif self.value == 4:  # uint8
            return 1
        elif self.value == 5:  # int32
            return 4
        elif self.value == 6:  # uint32
            return 4
        elif self.value == 7:  # int64
            return 8
        elif self.value == 8:  # uint64
            return 8
        else:
            return 4  # default


# ============================================================================
# GPU Execution Configuration
# ============================================================================

@register_passable("trivial")
struct GPUConfig:
    """GPU execution configuration."""
    var block_size_x: Int32
    var block_size_y: Int32
    var block_size_z: Int32
    var shared_memory_bytes: Int32
    var grid_size_x: Int32
    var grid_size_y: Int32
    var grid_size_z: Int32
    
    fn total_threads_per_block(self) -> Int32:
        """Calculate total threads per block."""
        return self.block_size_x * self.block_size_y * self.block_size_z
    
    fn total_threads(self) -> Int32:
        """Calculate total threads in grid."""
        return self.total_threads_per_block() * self.grid_size_x * self.grid_size_y * self.grid_size_z


@register_passable("trivial")
struct BlockIdx:
    """Block index in grid."""
    var x: Int32
    var y: Int32
    var z: Int32


@register_passable("trivial")
struct ThreadIdx:
    """Thread index within block."""
    var x: Int32
    var y: Int32
    var z: Int32


# ============================================================================
# Tensor Metadata
# ============================================================================

@register_passable("trivial")
struct TensorShape:
    """Tensor shape information."""
    var batch: Int32
    var seq_len: Int32
    var height: Int32
    var width: Int32
    
    fn total_elements(self) -> Int32:
        """Get total number of elements."""
        return self.batch * self.seq_len * self.height * self.width
    
    fn __init__(batch: Int32, seq_len: Int32, height: Int32, width: Int32) -> Self:
        return Self(batch=batch, seq_len=seq_len, height=height, width=width)


struct TensorMetadata:
    """Complete tensor metadata."""
    var shape: TensorShape
    var dtype: DType
    var batch_size: Int32
    var seq_length: Int32
    var num_heads: Int32
    var head_dim: Int32
    var num_kv_heads: Int32
    var vocab_size: Int32
    
    fn __init__(
        batch_size: Int32,
        seq_length: Int32,
        num_heads: Int32,
        head_dim: Int32,
        num_kv_heads: Int32,
        vocab_size: Int32,
        dtype: DType = DType.float32
    ) -> Self:
        let shape = TensorShape(
            batch=batch_size,
            seq_len=seq_length,
            height=num_heads,
            width=head_dim
        )
        return Self(
            shape=shape,
            dtype=dtype,
            batch_size=batch_size,
            seq_length=seq_length,
            num_heads=num_heads,
            head_dim=head_dim,
            num_kv_heads=num_kv_heads,
            vocab_size=vocab_size
        )
    
    fn hidden_size(self) -> Int32:
        """Get hidden size (num_heads * head_dim)."""
        return self.num_heads * self.head_dim
    
    fn kv_cache_size_per_token(self) -> Int32:
        """Get KV cache size per token (num_kv_heads * head_dim * 2 for K and V)."""
        return self.num_kv_heads * self.head_dim * 2


# ============================================================================
# Device Context and Memory Pointers
# ============================================================================

@register_passable("trivial")
struct DeviceMemory:
    """Device memory pointer with metadata."""
    var ptr: DTypePointer[DType.float32]
    var size_bytes: Int64
    var device_id: Int32
    var is_pinned: Bool
    
    fn __init__(
        ptr: DTypePointer[DType.float32],
        size_bytes: Int64,
        device_id: Int32 = 0,
        is_pinned: Bool = False
    ) -> Self:
        return Self(ptr=ptr, size_bytes=size_bytes, device_id=device_id, is_pinned=is_pinned)


struct DeviceContext:
    """GPU device context and configuration."""
    var device_id: Int32
    var stream_id: Int32
    var config: GPUConfig
    var max_shared_memory: Int32
    var compute_capability: Int32
    
    fn __init__(
        device_id: Int32 = 0,
        stream_id: Int32 = 0,
        block_size_x: Int32 = 256,
        block_size_y: Int32 = 1,
        block_size_z: Int32 = 1,
    ) -> Self:
        let config = GPUConfig(
            block_size_x=block_size_x,
            block_size_y=block_size_y,
            block_size_z=block_size_z,
            shared_memory_bytes=0,
            grid_size_x=1,
            grid_size_y=1,
            grid_size_z=1
        )
        return Self(
            device_id=device_id,
            stream_id=stream_id,
            config=config,
            max_shared_memory=96000,  # 96KB default for modern GPUs
            compute_capability=80  # A100 = 80, H100 = 90
        )
    
    fn set_grid_size(inout self, x: Int32, y: Int32, z: Int32):
        """Set grid dimensions."""
        self.config.grid_size_x = x
        self.config.grid_size_y = y
        self.config.grid_size_z = z
    
    fn set_shared_memory(inout self, bytes: Int32):
        """Set shared memory size."""
        self.config.shared_memory_bytes = bytes


# ============================================================================
# Kernel Computation Constants
# ============================================================================

@register_passable("trivial")
struct KernelConfig:
    """Kernel computation configuration."""
    var block_m: Int32  # M dimension per block
    var block_n: Int32  # N dimension per block
    var block_k: Int32  # K dimension per block
    var warp_m: Int32   # M dimension per warp
    var warp_n: Int32   # N dimension per warp
    var stages: Int32   # Pipeline stages
    var use_shared_memory: Bool
    
    fn __init__(
        block_m: Int32 = 128,
        block_n: Int32 = 128,
        block_k: Int32 = 32,
        warp_m: Int32 = 32,
        warp_n: Int32 = 32,
        stages: Int32 = 3,
        use_shared_memory: Bool = True
    ) -> Self:
        return Self(
            block_m=block_m,
            block_n=block_n,
            block_k=block_k,
            warp_m=warp_m,
            warp_n=warp_n,
            stages=stages,
            use_shared_memory=use_shared_memory
        )
    
    fn total_threads_needed(self) -> Int32:
        """Calculate threads needed for this config."""
        return (self.block_m * self.block_n) // (self.warp_m * self.warp_n)


# ============================================================================
# Synchronization Primitives
# ============================================================================

@register_passable("trivial")
struct SyncBarrier:
    """Thread synchronization barrier."""
    var barrier_id: Int32
    var phase: UInt32
    
    fn __init__(barrier_id: Int32 = 0) -> Self:
        return Self(barrier_id=barrier_id, phase=0)


# ============================================================================
# Memory Layout and Strides
# ============================================================================

@register_passable("trivial")
struct MemoryLayout:
    """Memory layout descriptor."""
    var strides: DynamicVector[Int32]
    var shape: DynamicVector[Int32]
    var is_contiguous: Bool
    var is_row_major: Bool
    
    fn element_offset(self, indices: DynamicVector[Int32]) -> Int32:
        """Calculate linear offset from multi-dimensional indices."""
        var offset: Int32 = 0
        for i in range(len(self.strides)):
            offset += indices[i] * self.strides[i]
        return offset


# ============================================================================
# Error Handling
# ============================================================================

@register_passable("trivial")
struct KernelStatus:
    """Kernel execution status."""
    var success: Bool
    var error_code: Int32
    var error_message_ptr: DTypePointer[DType.uint8]
    
    fn is_success(self) -> Bool:
        return self.success
    
    fn get_error_code(self) -> Int32:
        return self.error_code
